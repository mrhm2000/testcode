

        var df1 = pickupInfo.where(col("x") >= minX and
          col("x") <= maxX and col("y") >= minY and
          col("y") <= maxY and col("z") >= minZ and
          col("z") <= maxZ)
        df1 = df1.groupBy("x", "y", "z").count()
        df1.createOrReplaceTempView("hotcells")
        df1.show


        val countmean: Double = df1.agg(sum("count") / numCells).first.getDouble(0)
        val holder: Double = math.sqrt(df1.agg(sum(pow("count", 2.0)) /
          numCells - math.pow(countmean, 2.0)).first.getDouble(0))

        spark.udf.register("ST_Within", (
                                          point_x1: Int,
                                          point_y1: Int,
                                          point_z1: Int,
                                          point_x2: Int,
                                          point_y2: Int,
                                          point_z2: Int) =>
            (HotcellUtils.ST_Within(point_x1, point_y1, point_z1, point_x2, point_y2, point_z2)))
        var combineDf = spark.sql(
            "select hotcell_a.x as x, " +
                    "hotcell_a.y as y, " +
                    "hotcell_a.z as z, " +
                    "hotcell_b.count as count from hotcells hotcell_a, hotcells hotcell_b " +
                    "where ST_Within(hotcell_a.x, hotcell_a.y, hotcell_a.z, hotcell_b.x, hotcell_b.y, hotcell_b.z)")
        combineDf.show()

        combineDf = combineDf.groupBy("x", "y", "z").sum("count")
        newCoordinateName = Seq("x", "y", "z", "sum")
        combineDf = combineDf.toDF(newCoordinateName: _*)
        combineDf.createOrReplaceTempView("combineDf")

        spark.udf.register("gScore", (sum: Int) => HotcellUtils.gScore( holder, countmean, sum, numCells ))
        var finalDf = spark.sql("select x, y, z, gScore(sum) as score from combineDf")
        finalDf.sort(desc("score")).show()
        return finalDf.sort(desc("score")).limit(50).select("x","y","z")
        
        
        
    def ST_Within(point_x1:Int, point_y1:Int, point_z1:Int, point_x2:Int, point_y2:Int, point_z2:Int): Boolean = {
        var ans: Boolean = false

        if (math.abs(point_x1-point_x2)>1 || math.abs(point_y1-point_y2)>1 || math.abs(point_z1-point_z2)>1)
        {ans = false}
        else {ans = true}

        return ans
    }

    def gScore(holder:Double, countmean:Double, sum:Int, numCells:Double ): Double =
    {
        val score = (sum - countmean*27) / (holder*math.sqrt((numCells*27-math.pow(27,2.0))/(numCells-1)))
        return score
    }


